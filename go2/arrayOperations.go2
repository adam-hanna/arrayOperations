package go2

// Distinct returns the unique vals of a slice
//
// [1, 1, 2, 3] >> [1, 2, 3]
func Distinct[T comparable](arrs... []T) []T {
	// put the values of our slice into a map
	// the key's of the map will be the slice's unique values
	m := make(map[T]struct{})
	for idx1 := range arrs {
		for idx2 := range arrs[idx1] {
			m[arrs[idx1][idx2]] = struct{}{}
		}
	}

	// create the output slice and populate it with the map's keys
	res := make([]T, len(m))
	i := 0
	for k := range m {
		res[i] = k
		i++
	}

	return res
}

// Intersect returns a slice of values that are present in all of the input slices
//
// [1, 1, 3, 4, 5, 6] & [2, 3, 6] >> [3, 6]
//
// [1, 1, 3, 4, 5, 6] >> [1, 3, 4, 5, 6]
func Intersect[T comparable](arrs ...[]T) []T {
	m := make(map[T]int)

	var (
		tmpArr []T
		count int
		ok bool
	)
	for idx1 := range arrs {
		tmpArr = Distinct(arrs[idx1])

		for idx2 := range tmpArr {
			count, ok = m[tmpArr[idx2]]
			if !ok {
				m[tmpArr[idx2]] = 1
			} else {
				m[tmpArr[idx2]] = count + 1
			}
		}
	}

	var (
		ret []T
		lenArrs int = len(arrs)
	)
	for k, v := range m {
		if v == lenArrs {
			ret = append(ret, k)
		}
	}

	return ret
}

// Union returns a slice that contains the unique values of all the input slices
//
// [1, 2, 2, 4, 6] & [2, 4, 5] >> [1, 2, 4, 5, 6]
//
// [1, 1, 3, 4, 5, 6] >> [1, 3, 4, 5, 6]
func Union[T comparable](arrs ...[]T) []T {
	m := make(map[T]struct{})

	var tmpArr []T
	for idx := range arrs {
		tmpArr = Distinct(arrs[idx])

		for idx2 := range tmpArr {
			m[tmpArr[idx2]] = struct{}{}
		}
	}

	ret := make([]T, len(m))
	i := 0
	for k := range m {
		ret[i] = k
		i++
	}

	return ret
}

// Difference returns a slice of values that are only present in one of the input slices
//
// [1, 2, 2, 4, 6] & [2, 4, 5] >> [1, 5, 6]
//
// [1, 1, 3, 4, 5, 6] >> [1, 3, 4, 5, 6]
func Difference[T comparable](arrs ...[]T) []T {
	m := make(map[T]int)

	var (
		tmpArr []T
		count int
		ok bool
	)
	for idx1 := range arrs {
		tmpArr = Distinct(arrs[idx1])

		for idx2 := range tmpArr {
			count, ok = m[tmpArr[idx2]]
			if !ok {
				m[tmpArr[idx2]] = 1
			} else {
				m[tmpArr[idx2]] = count + 1
			}
		}
	}

	var (
		ret []T
	)
	for k, v := range m {
		if v == 1 {
			ret = append(ret, k)
		}
	}

	return ret
}
