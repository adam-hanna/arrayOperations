package go2

import (
	"fmt"
	"testing"
)

func isEqual[T comparable](a, b []T) bool {
	if len(a) != len(b) {
		return false
	}

	m1 := make(map[T]int)
	var (
		count int
		ok bool
	)
	for idx := range a {
		count, ok = m1[a[idx]]	
		if !ok {
			m1[a[idx]] = 1
		} else {
			m1[a[idx]] = count + 1
		}
	}

	m2 := make(map[T]int)
	for idx := range b {
		count, ok = m2[b[idx]]	
		if !ok {
			m2[b[idx]] = 1
		} else {
			m2[b[idx]] = count + 1
		}
	}

	for k, v := range m1 {
		count, ok = m2[k]
		if ! ok {
			return false
		}
		if count != v {
			return false
		}
	}
	for k, v := range m2 {
		count, ok = m1[k]
		if ! ok {
			return false
		}
		if count != v {
			return false
		}
	}

	return true
}

type testDistinctInput[T comparable] [][]T
type testDistinctOutput[T comparable] []T
type testDistinct[T comparable] struct {
	input testDistinctInput[T]
	output testDistinctOutput[T]
}

func TestDistinct(t *testing.T) {
		for i, tt := range []testDistinct[int] {
			testDistinct[int]{
				input: testDistinctInput[int]{
					[]int{1, 2, 3, 3, 4},
				},
				output: []int{1, 2, 3, 4},
			},
		} {
			t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
				actual := Distinct(tt.input...)

				if !isEqual(actual, tt.output) {
					t.Errorf("expected: %v %T, received: %v %T", tt.output, tt.output, actual, actual)
				}
		})
	}
}

type testIntersectInput[T comparable] [][]T
type testIntersectOutput[T comparable] []T
type testIntersect[T comparable] struct {
	input testIntersectInput[T]
	output testIntersectOutput[T]
}

func TestIntersect(t *testing.T) {
		for i, tt := range []testIntersect[int] {
			testIntersect[int]{
				input: testIntersectInput[int]{
					[]int{1, 2, 3, 3, 4},
					[]int{1, 2, 4},
					[]int{1, 3, 4},
				},
				output: []int{1, 4},
			},
		} {
			t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
				actual := Intersect(tt.input...)

				if !isEqual(actual, tt.output) {
					t.Errorf("expected: %v %T, received: %v %T", tt.output, tt.output, actual, actual)
				}
		})
	}
}

type testUnionInput[T comparable] [][]T
type testUnionOutput[T comparable] []T
type testUnion[T comparable] struct {
	input testUnionInput[T]
	output testUnionOutput[T]
}

func TestUnion(t *testing.T) {
		for i, tt := range []testUnion[int] {
			testUnion[int]{
				input: testUnionInput[int]{
					[]int{1, 2, 3, 3, 4},
					[]int{1, 2, 4, 5},
					[]int{1, 3, 4, 6},
				},
				output: []int{1, 2, 3, 4, 5, 6},
			},
		} {
			t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
				actual := Union(tt.input...)

				if !isEqual(actual, tt.output) {
					t.Errorf("expected: %v %T, received: %v %T", tt.output, tt.output, actual, actual)
				}
		})
	}
}

type testDifferenceInput[T comparable] [][]T
type testDifferenceOutput[T comparable] []T
type testDifference[T comparable] struct {
	input testDifferenceInput[T]
	output testDifferenceOutput[T]
}

func TestDifference(t *testing.T) {
		for i, tt := range []testDifference[int] {
			testDifference[int]{
				input: testDifferenceInput[int]{
					[]int{1, 2, 3, 3, 4},
					[]int{1, 2, 5},
					[]int{1, 3, 6},
				},
				output: []int{4, 5, 6},
			},
		} {
			t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
				actual := Difference(tt.input...)

				if !isEqual(actual, tt.output) {
					t.Errorf("expected: %v %T, received: %v %T", tt.output, tt.output, actual, actual)
				}
		})
	}
}
